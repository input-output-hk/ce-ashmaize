## Design

General guiding principles to make the algorithm more ASIC resistant

- Require large amount of memory: this is slow/expensive for ASIC.
- Data dependent control flow: Kill optimisation of flow on ASIC.
- Limit parallelism: Sequentiality reduces ASIC scalability.
- Algorithm complexity: Increase the number of operations needed to implement an ASIC

HashMaze is designed with 2 parts:

- generating a large deterministic pseudo random execution buffer
- emulating a generic CPU like instruction on top of this execution buffer


```
  +-------+                      +--------+
  |  Key  |                      |  Salt  |
  +---+---+                      +----+---+
      |                               |
      |                       +---+   |
+-----v-------+               |   |   |
|  RandomGen  |               |  +v---v-----+
+-----+-------+               |  | VM Init  |
      |                       |  +----+-----+
      |                       |       |
+-----v--+    +------------+  |       |
|  ROM   +----> ROM Digest |--+       |
+-----^--+    +------------+          |
      |                        +------v-------+
      |                        |              <-----\
      +------------------------+  VM Execute  |     |
                               |              +-----/
                               +------+-------+
                                      |
                                      |
                               +------v------+
                               | VM Finalize |
                               +------+------+
                                      |
                                      |
                                   +--v--+
                                   |Hash |
                                   +-----+
```


### Main Function

Main Function is defined as following:

```
# Hashmaze Hash
Function HashMaze(key, salt, romSize, nbInstructions)
    # Inputs:
    #   key:             Bytes
    #   salt:            Bytes
    #   romSize:         Integer (32..2^32-1)
    #   nbInstructions:  Integer (128..2^32-1)
    # Output:
    #   digest:          Bytes (64 bytes)

    rom = Rom(key, romSize)
    vm = vmInitialize(Blake2(Blake2(rom, 64) | salt, 64))

    for i = 0 to nbInstructions-1 do
        vmExec(vm, rom)
        vmForward(vm)

    vmFinalize()
```

Steps:

1. Create a large amount of Read only memory, initialized using a sequential
   hashing construction using the 'key'
2. Initialize a VM, and Execute a user chosen number of instruction, then finalize the state of the VM
   into a Digest

### Rom function

Generate a large amount of read only memory that will be used to execute instructions

```
Function Rom(key, romSize)
    # Inputs:
    #   password:        Bytes
    #   romSize:         Integer (32..2^32-1)
    # Output:
    #   digest:          Bytes (romSize bytes)
   return RomVariableLength(password, romSize)
```

### VM functions

The VM is a CPU, with some registers (generic registers + instruction pointer), and some
other state tracking.

* vmInitialize initialize the registers to arbitrary random value
* vmExec take the instruction pointer, read the instruction from ROM, and then execute
  an operation that change the state of the VM
* vmStep mix some stuff and move the instruction pointer
* vmFinalize take the state of the VM and produce a final digest

```
Function vmInitialize()
    TBD

Function vmExec()
    TBD

Function vmForward()
    TBD

Function vmFinalize()
    TBD
```


### Auxiliary function

This is the hash function from argon2 which produce a large output of data by
chunks of 32 bytes, where each chunk is dependant of the previous chunk.

```
# Variable length hash function (Argon2 Hash)
Function RomVariableLengthInitialize(message, digestSize)
    # Inputs:
    #   message:         Bytes (0..2^32-1)     Message to be hashed
    #   digestSize:      Integer (1..2^32)     Desired number of bytes to be returned
    # Output:
    #   digest:          Bytes (digestSize)   The resulting generated bytes, digestSize bytes long

    # Hash is a variable-length hash function, built using Blake2b, capable of generating
    # digests up to 2^32 bytes.

    # If the requested digestSize is 64-bytes or lower, then we use Blake2b directly
    if (digestSize <= 64) then
       return Blake2b(digestSize ∥ message, digestSize) // concatenate 32-bit little endian digestSize with the message bytes

    # For desired hashes over 64-bytes (e.g. 1024 bytes for Argon2 blocks),
    # we use Blake2b to generate twice the number of needed 64-byte blocks,
    # and then only use 32-bytes from each block

    # Calculate the number of whole blocks (knowing we're only going to use 32-bytes from each)
    r = Ceil(digestSize/32)-2;

    # Generate r whole blocks.
    # Initial block is generated from message
    V[0] ← Blake2b(digestSize ∥ message, 64);
    # Subsequent blocks are generated from previous blocks
    for i = 1 to r-1 do
       V[i] = Blake2b(V[i-1], 64)
    # Generate the final (possibly partial) block
    partialBytesNeeded ← digestSize – 32*r;
    V[r] = Blake2b(V[r-1], partialBytesNeeded)

    # Concatenate the first 32-bytes of each block V[i]
    # (except the possibly partial last block, which we take the whole thing)
    # Let A[i] represent the lower 32-bytes of block V[i]
    return A[0] | A[1] | ... | A[r-1] | V[r]
```
