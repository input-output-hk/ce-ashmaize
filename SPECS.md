### Main Function

Main Function is defined as following:

```
# Hashmaze Hash
Function HashMaze(password, romSize, nbInstructions)
    # Inputs:
    #   password:        Bytes
    #   romSize:         Integer (32..2^32-1)
    #   nbInstructions:  Integer (128..2^32-1)
    # Output:
    #  digest:           Bytes (64 bytes)

    rom = Rom(password, romSize)
    vm = vmInitialize(Blake2(rom, 64))

    for i = 0 to nbInstructions-1 do
        vmExec(vm, rom)
        vmStep(vm)

    vmFinalize()
```

### Rom function

Generate a large amount of read only memory that will be used to execute instructions

```
Function Rom(password, romSize)
    # Inputs:
    #   password:        Bytes
    #   romSize:         Integer (32..2^32-1)
    # Output:
    #   digest:          Bytes (romSize bytes)
   return RomVariableLength(password, romSize)
```

### VM functions

```
Function vmInitialize()
    TBD

Function vmExec()
    TBD

Function vmStep()
    TBD

Function vmFinalize()
    TBD
```


### Auxiliary function

This is the hash function from argon2 which produce a large output of data by
chunks of 32 bytes, where each chunk is dependant of the previous chunk.

```
# Variable length hash function (Argon2 Hash)
Function RomVariableLengthInitialize(message, digestSize)
    # Inputs:
    #   message:         Bytes (0..2^32-1)     Message to be hashed
    #   digestSize:      Integer (1..2^32)     Desired number of bytes to be returned
    # Output:
    #   digest:          Bytes (digestSize)   The resulting generated bytes, digestSize bytes long

    # Hash is a variable-length hash function, built using Blake2b, capable of generating
    # digests up to 2^32 bytes.

    # If the requested digestSize is 64-bytes or lower, then we use Blake2b directly
    if (digestSize <= 64) then
       return Blake2b(digestSize ∥ message, digestSize) // concatenate 32-bit little endian digestSize with the message bytes

    # For desired hashes over 64-bytes (e.g. 1024 bytes for Argon2 blocks),
    # we use Blake2b to generate twice the number of needed 64-byte blocks,
    # and then only use 32-bytes from each block

    # Calculate the number of whole blocks (knowing we're only going to use 32-bytes from each)
    r = Ceil(digestSize/32)-2;

    # Generate r whole blocks.
    # Initial block is generated from message
    V[0] ← Blake2b(digestSize ∥ message, 64);
    # Subsequent blocks are generated from previous blocks
    for i = 1 to r-1 do
       V[i] = Blake2b(V[i-1], 64)
    # Generate the final (possibly partial) block
    partialBytesNeeded ← digestSize – 32*r;
    V[r] = Blake2b(V[r-1], partialBytesNeeded)

    # Concatenate the first 32-bytes of each block V[i]
    # (except the possibly partial last block, which we take the whole thing)
    # Let A[i] represent the lower 32-bytes of block V[i]
    return A[0] | A[1] | ... | A[r-1] | V[r]
```
